//! Infrastructure to drive properties.
//!
//! Properties may be an f64, f64 3-vector, f64 6-vector, or a specialized object-specific type.  To get the properties
//! for an object, call the `props()` method on that object.  For example, `trig_waveform.props().frequency().set(val)`.
//! Simply executing `.props().frequency()` returns an object which may have other operations called on it; see the docs
//! on the [Property] struct for more.
use std::marker::PhantomData;

use crate::command::{CommandSender, CommandSenderExt, Port};
use crate::error::Result;

// Implementation:
//
// Properties have the following moving pieces:
//
// - The [Property] struct is what we expose to users. We don't use the convenient name internally because we want the
//   convenient name for the public API.
// - The [CommandSender] trait is implemented for handles, usually by macros.  It allows dispatching commands to the
//   audio thread.
// - Nodes which wish to contain properties use a struct composed of [Slot]s and write their own `.props()` method which
//   returns some type that contains `.prop_name()` [Property] builders.  The struct itself usually just contains a
//   reference to the parent as a [CommandSender] to be passed to [Property]s private constructor.
// - The struct containing the properties must also implement [PropertyCommandReceiver], which is called by [NodeAt]
//   when property commands reach the node, unless the user's node overrides [NodeAt]'s defaults.
//
// there's a lot here, so here is the flow for when a user manipulates a property:
//
// - The user wants to manipulate a sine wave's frequency. They call `sine.props().frequency()` returning [Property]
//   containing `&dyn CommandSender`.  The struct [Property] contains a numeric index to the [Slot].
// - The user calls `.set(value)`.  This will "dereference" the property and send a property-setting commandd which
//   contains a property index and a [Value].
// - Next, [crate::nodes::NodeAt] sees this command.  It calls `get_prop_slots()` on itself, a required method returning
//   `&mut dyn PropertyCommandReceiver`.
// - The implementation of [PropertyCommandReceiver] has an appropriate method called on it.
// - (usually autogenerated) code dispatches this to the right [Slot].
// - The [Slot] marks itself changed so that nodes can be aware of any changes to avoid expensive operations.
//
// In the near future, `Slot<F64X1>` will furthermore support connections from graphs, which will be handled by `NodeAt`
// calling out to [PropertyCommandReceiver] to tell it about connections, and possibly-mixed buffers to link up to
// properties.

// Value marker types.
//
// We want to use the `Variant` infrastructure. Furthermore we may in future wish to avoid the orphan rules w.r.t.
// implementing private traits and the like.  To do so, we wrap values in structs.

/// Marker type for a property whose value is an F64 scalar.  Such properties take f64s in their `.set()` methods.
#[derive(Copy, Clone, PartialEq, PartialOrd, Debug, Default)]
pub struct F64X1(f64);

mod sealed {
    use super::*;

    variant!(pub PropertyValue, F64X1);

    /// Knows how to let users work with friendlier types than our markers.
    pub trait PropertyKind: TryFrom<PropertyValue> + Into<PropertyValue> + std::fmt::Debug {
        type ContainedType: Copy;

        fn lift(val: Self::ContainedType) -> Self;

        fn extract(&self) -> Self::ContainedType;
    }
}
pub(crate) use sealed::*;

impl PropertyKind for F64X1 {
    type ContainedType = f64;

    fn lift(val: Self::ContainedType) -> Self {
        Self(val)
    }

    fn extract(&self) -> Self::ContainedType {
        self.0
    }
}

/// Command to perform an operation on a property.
#[derive(Debug)]
pub(crate) enum PropertyCommand {
    Set { index: usize, value: PropertyValue },
}

/// Trait implemented by structs containing a [Slot] which will have the methods called on it as commands are
/// received and other interesting events happen.
pub(crate) trait PropertyCommandReceiver {
    /// This node is about to tick for the first time.
    ///
    /// Should mark all properties changed due to the first tick. See [PropertyChangeState].
    fn tick_first(&mut self);

    /// Called immediately *after* a node finishes ticking.
    ///
    /// Should clear all properties as unchanged. in preparation for what may be more user commands.
    fn tick_ended(&mut self);

    /// Called to set a property.
    ///
    /// This should panic if the value is of the wrong type.  We must erase the type information in order to have
    /// something we can pas over command queues without validation, but the public API should ensure that programs only
    /// compile if the types line up or, failing that, that the user has clearly been warned that misuse may panic.
    fn set_property(&mut self, index: usize, value: PropertyValue);
}

/// The unit type means no properties.
///
/// Everything "automatic" (e.g. tick start/end) does nothing; everything user-facing errors out because it shouldn't be
/// possible to get a command into the node via the public API.
impl PropertyCommandReceiver for () {
    fn set_property(&mut self, _index: usize, _value: PropertyValue) {
        panic!("This node has no properties");
    }

    fn tick_ended(&mut self) {}

    fn tick_first(&mut self) {}
}

/// A reference to a property.
///
/// To get one, call `.props().name()` on a node of your choice.
pub struct Property<'a, MarkerType: PropertyKind> {
    index: usize,
    sender: &'a dyn CommandSender,
    port: Port,
    _phantom: PhantomData<*const MarkerType>,
}

impl<'a, V: PropertyKind> Property<'a, V> {
    /// Create a reference to a property with the given index.
    pub(crate) fn new(sender: &'a dyn CommandSender, port: Port, index: usize) -> Self {
        Self {
            index,
            sender,
            port,
            _phantom: PhantomData,
        }
    }

    /// Set the value of this property.
    ///
    /// This is done by sending a command to the audio thread, and so property sets happen with some latency.
    /// Furthermore, Synthizer does not have the ability to validate ranges, so any out-of-range values will be clamped
    /// as necessary on the audio thread.  This may seem odd, but if one is also connecting to a property for automation
    /// purposes then it is possible that the sum is in range even when individual sets aren't, and this can't be
    /// checked except on the audio thread itself.
    pub fn set_value(&self, val: V::ContainedType) -> Result<()> {
        self.sender.send(
            self.port,
            PropertyCommand::Set {
                index: self.index,
                value: V::lift(val).into(),
            },
        )
    }
}

/// Whether and how a property has changed.
#[derive(Copy, Clone, Eq, Ord, PartialEq, PartialOrd, Debug, Hash, derive_more::IsVariant)]
pub(crate) enum ChangeState {
    /// This property has not changed since the last audio tick.
    Unchanged,

    /// This is the first tick, so this property should be considered changed.
    FirstTick,

    /// This property was changed for some other reason, usually the user sending commands.
    Other,
}

impl ChangeState {
    /// Return true if this property has changed for any reason since the last tick.
    pub(crate) fn is_changed(&self) -> bool {
        !self.is_unchanged()
    }
}

/// A slot containing a property value.
///
/// This is the convenience container for internal usage when deriving/macro-implementing structs that contain concrete
/// property data.  The marker here should match up with the marker for [Property] which was handed out to the user.
pub(crate) struct Slot<Marker: PropertyKind> {
    data: Marker::ContainedType,
    change_state: ChangeState,
}

impl<V: PropertyKind> Slot<V> {
    pub(crate) fn new(default_value: V::ContainedType) -> Self {
        Self {
            data: default_value,
            change_state: ChangeState::Unchanged,
        }
    }

    pub(crate) fn get_value(&self) -> V::ContainedType {
        self.data
    }

    /// Try to set this property from a [PropertyValue] and panic if this was not possible.
    pub(crate) fn set_from_property_value(&mut self, val: PropertyValue, why: ChangeState) {
        let Ok(val): Result<V,_> = val
            .try_into()
            else {
                panic!("Internal error: a property value of the wrong type reached a property slot");
            };

        self.data = val.extract();
        self.change_state = why;
    }

    /// Return whether or not this slot has changed since the last tick.
    pub(crate) fn is_changed(&self) -> bool {
        self.change_state.is_changed()
    }

    /// Get the value for this property only if it has changed.
    pub(crate) fn get_value_if_changed(&self) -> Option<V::ContainedType> {
        if self.is_changed() {
            Some(self.get_value())
        } else {
            None
        }
    }

    /// Mark this slot as unchanged since the last tick.
    pub(crate) fn mark_unchanged(&mut self) {
        self.change_state = ChangeState::Unchanged;
    }

    /// Mark this slot as changed because this is the first tick.
    pub(crate) fn mark_first_tick(&mut self) {
        self.change_state = ChangeState::FirstTick;
    }
}
